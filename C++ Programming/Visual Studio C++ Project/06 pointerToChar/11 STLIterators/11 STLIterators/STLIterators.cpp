#include <string>
#include <vector>
#include <array>
#include <deque>
#include <list>
#include <forward_list>
#include <queue>
#include <stack>
#include <map>
#include <set>
#include <unordered_set>
#include <unordered_map>
#include <iostream>
#include <algorithm>
using namespace std;

int main()
{
	string s;										// 
	string::const_iterator sci;						// const forward iterator read only access
	string::const_reverse_iterator scri;			// const reverse iterator read only backwards access
	string::iterator si;							// forward iterator read write access
	string::reverse_iterator sri;					// reverse iterator read write access

	vector<int> v;					
	vector<int>::const_iterator vci;				// const forward iterator read only access
	vector<int>::const_reverse_iterator vcri;		// const reverse iterator read only backwards access
	vector<int>::iterator vi;						// forward iterator read write access
	vector<int>::reverse_iterator vri;				// reverse iterator read write access

	array <int, 5> a;
	array <int, 5>::const_iterator aci;				// const forward iterator read only access
	array <int, 5>::const_reverse_iterator acri;	// const reverse iterator read only backwards access
	array <int, 5>::iterator ai;					// forward iterator read only backwards access
	array <int, 5>::reverse_iterator ari;			// reverse iterator read write access

	deque <int> d;
	deque <int>::const_iterator dci;				// const forward iterator read only access
	deque <int>::const_reverse_iterator dcri;		// const reverse iterator read only backwards access
	deque <int>::iterator di;						// forward iterator read only backwards access
	deque <int>::reverse_iterator dri;				// reverse iterator read write access

	list <int> l;
	list <int>::const_iterator lci;					// const forward iterator read only access
	list <int>::const_reverse_iterator lcri;		// const reverse iterator read only backwards access
	list <int>::iterator li;						// forward iterator read only backwards access
	list <int>::reverse_iterator lri;				// reverse iterator read write access

	forward_list <int> f1;
	forward_list <int>::const_iterator flci;		// const forward interator read only access
	forward_list <int>::iterator fli;				// forward iterator read write access

	queue<int> q;									// no iterators

	priority_queue <int> pq;						// no iterators

	stack<int> st;									// on iterators

	map <int, int> m;								
	map <int, int>::const_iterator mci;				// const forward iterator read only access
	map <int, int>::const_reverse_iterator mcri;	// const reverse iterator read only backwards access
	map <int, int>::iterator mi;					// forward iterator read write access
	map <int, int>::reverse_iterator mri;			// reverse iterator read write access

	multimap <int, int> mm;
	multimap <int, int>::const_iterator mmci;		// const forward iterator read only access
	multimap <int, int>::const_reverse_iterator mmcri;// const reverse iterator read only backwards access
	multimap <int, int>::iterator mmi;				// forward iterator read write access
	multimap <int, int>::reverse_iterator mmri;		// reverse iterator read write access
	
	set <int, int> st1;					
	set <int, int>::const_iterator seci;			// const forward iterator read only access
	set <int, int>::const_reverse_iterator setcri;	// const reverse iterator read only backwards access
	set <int, int>::iterator seti;					// forward iterator read write access
	set <int, int>::reverse_iterator setri;			// reverse iterator read write access

	multiset <int, int> ms;
	multiset <int, int>::const_iterator msci;		// const forward iterator read only access
	multiset <int, int>::const_reverse_iterator mscri;// const reverse iterator read only backwards access
	multiset <int, int>::iterator msi;				// forward iterator read write access
	multiset <int, int>::reverse_iterator msri;		// reverse iterator read write access

	unordered_set <int, int> us;
	unordered_set <int, int>::const_iterator usci;	// const forward iterator read only access
	unordered_set <int, int>::iterator usi;			// forward iterator read write access

	unordered_multiset <int, int> ums;
	unordered_multiset <int, int>::const_iterator umsci; // const forward iterator read only access
	unordered_multiset <int, int>::iterator umsi;		 // forward iterator read write access

	unordered_map <int, int> um;
	unordered_map <int, int>::const_iterator umci; // const forward iterator read only access
	unordered_map <int, int>::iterator umi;		// forward iterator read write access

	unordered_multimap <int, int> umm;
	unordered_multimap <int, int>::const_iterator ummci; // const forward iterator read only access
	unordered_multimap <int, int>::iterator ummi;		 // forward iterator read write access 


	// Iterators can be generated by STL container member functinons, such as begin() and end().

	// Iterators are divided into classes. These are not real C++ classes, but simply
	// categories of kind of iterators. Each category specifies the operations the
	// iterator supports. For example, some iterators support incrementing but not
	// decrementing, some support dereferencing for getting data but not for storing data,
	// some support scalar arithmetic, i.e., adding n, and some don't. Each STL container
	// defines whta class of iteratiors it can return. Each algorithm specifies what class
	// of iterators it requires. The more powerful iterator classes are usually sublcasses
	// of the weaker ones, so if an algorithm requires a minimal iterator, it will work
	// just fine with an iterator with more power.

	// InputIterator is a useful but limmited class of iterators. If iter is an
	// InputIterator, you can use :

	// ++iter and iter++ to increment it, i.e., advance the poiner to the next element
	// *iter to dereference it, i.e., get the element pointed to
	// == and != to compare it another iterator(typically the "end" iterator)

	vector<int> v1;
	vector<int>::iterator v1iter;

	v1.push_back(1);
	v1.push_back(2);
	v1.push_back(3);

	for (v1iter = v1.begin(); v1iter != v1.end(); v1iter++)
	{
		cout << (*v1iter) << endl;
	}

	// This is called input iterator because you can only use it to "read" data
	// from a container. You can't use it to store data, that is,

	// *v1iter = 4;

	// is illegal if iter is no more than input iterator. It will work for the
	// iterator above because vectors return iterators more powerful than just input
	// iterators. But if iter were an istream iterator(discussed shortly), then the above
	// restriction would apply.

	// OutputIterator is another limited class of iterators, basically the opposite of 
	// InputIterator. If iter is an OutputIterator, you can use :

	// ++iter and iter++ to increment it, i.e., advance the pointer to the next element
	// *iter = ... to store data in the location pointed to

	// Output iterators are only for storing. If something is no more than an output
	// iterator, you can't read from it with *iter, nor can you test it with == and !=.

	// It may seem like an iterator you can only write to, not read from, is about as
	// useful as a chocolate teapot, however, there are two very useful subclasses of
	// OutputIterator :

	// insert operators
	// ostream iterators

	// Insert iterators let you "point" to some location in a container and insert elements.
	// You do this just dereferencing add assignment:

	// *iter = value;

	// This inserts the value in the place pointed to by the iterator. If you assign again,
	// a new value will be inserted. Whether value goes before or after the previous value
	// depends on what kind of insert operator you've created. NOtice that you don't meed to
	// increment the iterator. You just keep assigning.

	// You create an insert iterator with one of the following :

	// back_inserter <container> returns an OutputIterator pointing to the end of the
	//	container. Output to this iterator gets added to the end of the container,
	//	using the container's push_back() operation.
	// front_inserter<container> returns an OutputIterator poining to the front of the 
	//	container. Output to this iterator gets added to the front of the container, 
	//	usign the container's push_front() operation.

	// inserter<container, iterator> returns an OutputItertor pointing to the location
	//	pointed to by interator of the container. Output to this iterator gets added to
	//  the container from that point forward, using the container's insert() operation.

	// Ostream OutputIterator

	// Ostream iterators let you "point" to an output stream insert elements into it,
	// i.e., write to the output stream.
	
	// We can construct an ostream iterator from a C++ output stream as follows :

	ostream_iterator<int> outIter(cout, " ");
	vector <int> voi;
	voi.push_back(10);
	voi.push_back(5);
	voi.push_back(99);
	copy(voi.begin(), voi.end(), outIter);
	cout << endl;

	// The first line defines outIter to be an ostream iterator for integers. The " " means
	// "put a space between each integer." If we'd said "\n" then outIter would put a
	// newline between each integer. The last line uses the generic algorithm copy() to
	// copy our vector v from beginning to end to cout. Note how much simpler this is than
	// the equivalent for loop with cout and <<.

	// Istream InputIterator

	// Istream iterators for input streams work similarly to ostream iterators. Istream
	// iterators are InputIterators. The following code fragment constructors an istream
	// iterator that reads integers from cin and copies them into a vector v. We use a 
	// back_inserter to add the elements to the vector, which could beempty :

	// copy(istream_iterator<int>(cin),
	// istream_iterator<int>(),
	// back_inserter(v));

	// The first argument to copy calls an istream iterator constructor that simply points
	// to the input stream cin. The second argument calls a special constructor that
	// creates a pointer to "the end of the input." What this actually means, especially
	// for terminal input, depends on your operating system. So the above says
	// "copy from the current item in the input sream to the end of the input stream into
	// the container v."

	// ForwardIterator

	// ForwardIterator combines InputIterator and OutputIterator, You can use them to read
	// and write to a container.

	// BidirectionalIterator

	// If iter is a BidirectionalIterator, you can use :

	// all ForwardIterator operations
	// --iter and iter-- to decrement it, i.e., advance the pointer to the previous element

	// RandomAccessIterator

	// If iter1 and iter2 are RandomAccessIterator's, you can use:

	// all BidirectionalIterator operations
	// standard pointer arithmetic, i.e., iter + n, iter - n, iter += n, iter -= n,
	// and iter1 - iter2 (but not iter1 + iter2)
	// all comparsions, i.e., iter1 > iter2, iter1 < iter2, iter1 >= iter2, and iter <= iter2

	// Since BidirectionalIterator's support ++ and --, don't they support these operations
	// too? The answer is that RandomAccessIterator's support these operations in constant
	// time. That is, you can jump N elements in the same time it takes to jump 1 element.
	// So an STL list container can return a BidirectionalIterator, but not a
	// RandomAccessIterator, Vectors and deques can return RandomAccessIterator's.

	return (0);
}
